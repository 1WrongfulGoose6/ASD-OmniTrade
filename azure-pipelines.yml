## Author: Ali Bonagdaran

trigger:
  branches:
    include:
      - '*'

pool:
  vmImage: ubuntu-latest

variables:
  nodeVersion: '20.x'
  HUSKY: '0'
  CI: 'true'
  NODE_OPTIONS: '--max-old-space-size=4096'  # Increase Node.js memory limit
  EnableCoverityScan: 'false'  # Toggle to run Coverity Scan job
  COVERITY_SCAN_PROJECT: 'ASD-OmniTrade'  # Update to exact Coverity project name
     
stages:
  - stage: CI
    displayName: 'Continuous Integration'
    jobs:
      - job: CoverityScan
        displayName: 'Coverity Static Analysis'
        condition: and(succeeded(), eq(variables['EnableCoverityScan'], 'true'))
        steps:
          - template: .azure/templates/setup-node.yml

          - script: |
              set -euo pipefail
              TOOL_ARCHIVE="coverity_tool.tgz"
              echo "Downloading Coverity Scan CLI..."
              curl -fsSL https://scan.coverity.com/download/linux64 \
                --form token="$(COVERITY_SCAN_TOKEN)" \
                --form project="$(COVERITY_SCAN_PROJECT)" \
                -o "${TOOL_ARCHIVE}"

              mkdir -p coverity_tool
              tar -xzf "${TOOL_ARCHIVE}" --strip-components=1 -C coverity_tool
            displayName: 'Download Coverity Scan CLI'
            env:
              COVERITY_SCAN_TOKEN: $(COVERITY_SCAN_TOKEN)
              COVERITY_SCAN_PROJECT: $(COVERITY_SCAN_PROJECT)

          - script: |
              set -euo pipefail
              export COVERITY_HOME="$(System.DefaultWorkingDirectory)/coverity_tool"
              export PATH="$COVERITY_HOME/bin:$PATH"

              echo "Capturing build with Coverity..."
              cov-build --dir cov-int npm run build:ci

              echo "Packaging Coverity intermediate directory..."
              tar -czf cov-int.tgz cov-int
            displayName: 'Capture build with Coverity'
            env:
              NEXT_TELEMETRY_DISABLED: 1

          - script: |
              set -euo pipefail
              echo "Uploading analysis data to Coverity Scan..."
              curl --progress-bar --fail \
                --form token="$(COVERITY_SCAN_TOKEN)" \
                --form email="$(COVERITY_SCAN_EMAIL)" \
                --form file=@cov-int.tgz \
                --form version="$(Build.BuildNumber)" \
                --form description="Azure Pipeline build $(Build.BuildNumber) ($(Build.SourceBranchName))" \
                https://scan.coverity.com/builds?project="$(COVERITY_SCAN_PROJECT)"
            displayName: 'Upload results to Coverity Scan'
            env:
              COVERITY_SCAN_TOKEN: $(COVERITY_SCAN_TOKEN)
              COVERITY_SCAN_EMAIL: $(COVERITY_SCAN_EMAIL)
              COVERITY_SCAN_PROJECT: $(COVERITY_SCAN_PROJECT)

      - job: Lint
        displayName: 'Lint Code'
        steps:
          - template: .azure/templates/setup-node.yml
          - script: npm run lint:ci || true
            displayName: 'Run ESLint with caching'
            env:
              NEXT_TELEMETRY_DISABLED: 1

      - job: UnitTests
        displayName: 'Unit Tests'
        steps:
          - template: .azure/templates/setup-node.yml
          - script: npm run test:coverage
            displayName: 'Run Unit Tests with Coverage'
            env:
              CI: true
              NEXT_TELEMETRY_DISABLED: 1
          - task: PublishTestResults@2
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'test-results/**/*.xml'
          - task: PublishCodeCoverageResults@2
            condition: succeededOrFailed()
            inputs:
              summaryFileLocation: 'coverage/cobertura-coverage.xml'
              pathToSources: 'src/'

      # playwright tests only on main branch or when explicitly requested

      - job: E2ETests
        displayName: 'E2E Tests'
        condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['FORCE_E2E'], 'true'))
        steps:
          - template: .azure/templates/setup-node.yml
          - script: npx playwright install --with-deps chromium
            displayName: 'Install Playwright browsers'
          - script: npm run test:e2e:ci
            displayName: 'Run E2E Tests'
            env:
              CI: true
              NEXT_TELEMETRY_DISABLED: 1
          - task: PublishTestResults@2
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'test-results/**/*.xml'

      - job: Build
        displayName: 'Build Application'
        dependsOn: [Lint, UnitTests]
        steps:
          - template: .azure/templates/setup-node.yml
          - task: Cache@2
            displayName: 'Cache Next.js build'
            continueOnError: true
            inputs:
              key: 'nextjs | "$(Agent.OS)" | package-lock.json | $(Build.SourceVersion)'
              path: '.next/cache'
              restoreKeys: |
                nextjs | "$(Agent.OS)" | package-lock.json
          - script: npm run build:ci
            displayName: 'Build Application'
            env:
              NEXT_TELEMETRY_DISABLED: 1
          - task: PublishPipelineArtifact@1
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              targetPath: '$(System.DefaultWorkingDirectory)'
              artifactName: 'WebApp'
              publishLocation: 'pipeline'
            displayName: 'Publish build artifacts'

  - stage: Deploy
    displayName: 'Deploy to Production'
    dependsOn: CI
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: Production
        displayName: 'Deploy to Azure App Service'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: current
                  artifact: WebApp
                  displayName: 'Download build artifacts'
                
                # Install dependencies and run database migrations
                - task: UseNode@1
                  inputs:
                    version: $(nodeVersion)
                  displayName: 'Use Node.js for deployment'
                
                - script: |
                    cd $(Pipeline.Workspace)/WebApp
                    npm ci --only=production
                  displayName: 'Install production dependencies'
                

                - script: |
                    cd $(Pipeline.Workspace)/WebApp
                    echo "Configuring database connection..."
                    # Use the helper script to build a properly encoded DATABASE_URL
                    DATABASE_URL=$(node scripts/build-db-url.js)
                    echo "DATABASE_URL=$DATABASE_URL" > .env
                    echo "NODE_ENV=production" >> .env
                    echo "PORT=8080" >> .env
                    echo "HOSTNAME=0.0.0.0" >> .env
                    echo "FINNHUB_API_KEY=$FINNHUB_API_KEY" >> .env
                    echo "Database configuration complete"
                    echo "Clearing existing migrations for provider switch..."
                    rm -rf prisma/migrations
                    npx prisma generate
                    echo "Syncing schema with prisma db push..."
                    npx prisma db push --skip-generate
                  displayName: 'Run database migrations'
                  env:
                    AZURE_POSTGRESQL_HOST: $(AZURE_POSTGRESQL_HOST)
                    AZURE_POSTGRESQL_USER: $(AZURE_POSTGRESQL_USER)
                    AZURE_POSTGRESQL_PASSWORD: $(AZURE_POSTGRESQL_PASSWORD)
                    AZURE_POSTGRESQL_DATABASE: $(AZURE_POSTGRESQL_DATABASE)
                    AZURE_POSTGRESQL_PORT: $(AZURE_POSTGRESQL_PORT)
                    FINNHUB_API_KEY: $(FINNHUB_API_KEY)
                
                # Build the DATABASE_URL with proper encoding
                - script: |
                    cd $(Pipeline.Workspace)/WebApp
                    DB_URL=$(node scripts/build-db-url.js)
                    echo "##vso[task.setvariable variable=ENCODED_DATABASE_URL]$DB_URL"
                  displayName: 'Build encoded DATABASE_URL'
                  env:
                    AZURE_POSTGRESQL_HOST: $(AZURE_POSTGRESQL_HOST)
                    AZURE_POSTGRESQL_USER: $(AZURE_POSTGRESQL_USER)
                    AZURE_POSTGRESQL_PASSWORD: $(AZURE_POSTGRESQL_PASSWORD)
                    AZURE_POSTGRESQL_DATABASE: $(AZURE_POSTGRESQL_DATABASE)
                    AZURE_POSTGRESQL_PORT: $(AZURE_POSTGRESQL_PORT)
                
                - task: AzureWebApp@1
                  inputs:
                    azureSubscription: 'OmniTrade Connection'
                    appType: 'webAppLinux'
                    appName: 'OmniTrade'
                    package: '$(Pipeline.Workspace)/WebApp'
                    runtimeStack: 'NODE|20-lts'
                    startUpCommand: 'npm start'
                    appSettings: '-NODE_ENV production -PORT 8080 -DATABASE_URL "$(ENCODED_DATABASE_URL)" -FINNHUB_API_KEY "$(FINNHUB_API_KEY)"'
                  displayName: 'Deploy to Azure App Service'
